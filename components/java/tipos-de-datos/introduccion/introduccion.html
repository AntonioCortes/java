<h1 class="title">Introduccion a los tipos</h1>


<h2>Declaración de variables</h2>

<p>Es la forma en la que se reserva un espacio en memoría con el fin de guardar datos.</p>
<p>El tamaño del espacio vendrá determinado por el tipo de dato.</p>

<p><b>[tipo][identificador]</b></p>

<p>Declaración multiple ejemplo:</p>
<div class="center-horizontal">
<pre><code class="language-java">
int numero1, numero2, numero3; // BIEN
int numero1, int numero2, int numero3; // MAL error de compilación

int numero1; int numero2; int numero3; 
//El ejemplo anterior aunque funciona no se 
//considera declaración multiple 
//ya que está separado por punto y coma.
</code></pre>	
</div>


<h2>Inicialización</h2>

<p>Consiste en la asignación de un valor a la variable.</p>

<div class="center-horizontal">
<pre><code class="language-java">
int numero = 3;
String name = "Juan";
</code></pre>	
</div>

<p>Inicialización múltiple y parcial múltiple</p>
<div class="center-horizontal">
<pre><code class="language-java">
short num0 = 23, num1 = 56, num2 = 87; // Inicialización multiple
String name0, name1 = "Juan", name2; // Inicialización parcial múltiple
</code></pre>	
</div>

<p>Inicialización por defecto:</p>
<ul>
    <li>
    Variables locales: NO se inicializan por defecto. Es necesario asignarles un valor antes de utilizarlas.
    </li>
    <li>
    Variables atributo: Se inicializan por defecto.
    </li>
</ul>


<h2>Conversión de tipos</h2>




<h2>Identificadores</h2>

<p>Se puede utilizar cualquier combinación de letras, números, $ y _.</p>
<p>Existen las siguientes restricciones:</p>
<ul>
    <li>
        No se pueden utilizar palabras reservadas como identificador (incluido "goto"). A excepción de "var".
    </li>
    <li>
        No puede comenzar por carácter numérico.
    </li>
</ul>

<div class="center-horizontal">
<pre><code class="language-java">
int _1=10; //ok
char break; //error
int 3aj; //error
float car.t; //error
</code></pre>	
</div>

<p>Aceptado lo siguiente:</p>
<p><b>NOTA:</b> se acepta el guion si es mas de uno ejemplo:</p>
<p><em>BIEN</em> int ___;</p>
<p><em>MAL</em> int _;</p>

<h2>Mutabilidad de variables</h2>
<p>En Java, una variable mutable es aquella cuyo valor se puede cambiar después de haber sido inicializada, mientras que una variable inmutable es aquella cuyo valor no puede ser modificado después de haber sido asignado.</p>
<p>En Java, los tipos primitivos como int, float, double, boolean, char, entre otros, son inmutables. Esto significa que una vez que se asigna un valor a una variable de tipo primitivo, no se puede modificar su valor.</p>
<p>Por otro lado, los objetos en Java son mutables, a menos que se especifique lo contrario. Para hacer un objeto inmutable, se debe asegurar que sus atributos no puedan ser modificados después de la creación del objeto. Esto se logra generalmente declarando los atributos como privados y proporcionando sólo getters públicos, sin setters. Por ejemplo, la clase String es inmutable en Java, lo que significa que una vez creado un objeto de esta clase, su valor no puede ser modificado.</p>
<div class="center-horizontal">
<pre><code class="language-java">
public final class ImmutableClass {
    private final int value;
    
    public ImmutableClass(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}    
</code></pre>	
</div>

<h2>Ámbito</h2>

<p>A nivel de clase compartidas por todos los métodos. Se les conoce como atributos o campos</p>
<p>En el interior de un método. Se les conoce como locales. Solo visibles dentro de ese método</p>






<h2>Tipos primitivos y variables objetos</h2>

<p>En la asignación de un variable con tipo primitivo a otra, ocurre que, cada variable tendrá su propio espacio reservado en memoria. En cambio a la hora de hacer esto mismo pero con objetos ambas variables apuntan al mismo valor.</p>
<p>Ejemplo:</p>

<div class="center-horizontal">
<pre><code class="language-java">
    //Distinto espacio en memoria y distinto valor.
    int a = 23;
    int b = a;

    //Distinto espacio en memoria y ambos apuntan al mismo valor.
    Object objeto1 = new Object();
    Object objeto2 = objeto1;
</code></pre>	
</div>

<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Numéricos</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Tipo de datos</th>
            <th>Bits</th>
            <th>Tamaño positivo</th>
            <th>Tamaño negativo</th>
        </tr>
        <tr>
            <td>byte</td>
            <td>8 bits</td>
            <td>127</td>
            <td>-128</td>
        </tr>
        <tr>
            <td>short</td>
            <td>16 bits</td>
            <td>32.767</td>
            <td>-32.768</td>
        </tr>
        <tr>
            <td>int</td>
            <td>32 bits</td>
            <td>2.147.483.647</td>
            <td>-2.147.483.648</td>
        </tr>
        <tr>
            <td>long</td>
            <td>64 bits</td>
            <td>9.223.372.036.854.780.000</td>
            <td>-9.223.372.036.854.780.000</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Default value 0 or 0L</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Binary 0b1001 Octal 072 Decimal 1234 Hex 0x4F Upper or lowercase L at the end indicates long value.</td>
        </tr>
    </tbody>
</table>


<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Decimales</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Tipo de datos</th>
            <th>Bits</th>
            <th>Tamaño positivo</th>
            <th>Tamaño negativo</th>
        </tr>
        <tr>
            <td>float</td>
            <td>32 bits</td>
            <td>3.4E38</td>
            <td>1.4E-45</td>
        </tr>
        <tr>
            <td>double</td>
            <td>64 bits</td>
            <td>1.797E308</td>
            <td>4.9E-324</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Default value 0.0 or 0.0F</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Normal 123.4 or exponential notations 1.234E2; Upper or lowercase F at the end indicates float value.</td>
        </tr>
    </tbody>
</table>

<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Boolean</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Tipo de datos</th>
            <th>Bits</th>
        </tr>
        <tr>
            <td>boolean</td>
            <td>1 bit</td>
        </tr>
    </tbody>
</table>

<div class="center-horizontal">
<pre><code class="language-java">
boolean variable = true;
boolean variable_2 = false;
</code></pre>	
</div>

<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Character</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Tipo de datos</th>
            <th>Bits</th>
            <th>Tamaño positivo</th>
            <th>Tamaño negativo</th>
        </tr>
        <tr>
            <td>char</td>
            <td>16 bits</td>
            <td>65.535</td>
            <td>0</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Default value '\u0000'</td>
        </tr>
        <tr style="text-align: center;">
            <td colspan="4">Character 'A' ASCII code '\101' Unicode '\u0041' escape Sequences: tab '\t' backspace '\b' new line '\n' carriage return '\r' form feed '\f' single quote \' double quote \" backslash \\</td>
        </tr>
    </tbody>
</table>

<p><b>NOTA:</b> Se pueden hacer calculos con el tipo char con el fin de obtener otro caracter representado por su valor numérico.</p>

<div class="center-horizontal">
<pre><code class="language-java">
char caracter = 64;
char caracter_2 = 'T';
char caracter_3 = 'u\1001'
</code></pre>	
</div>

<h4>Anotaciones sobre tipos</h4>

<p>El compilador interpreta que los números que no llevan decimales son enteros. Aquí hay error de compilacion ya que se interpreta que es un entero y se pasa de grande:</p>
<em>long numLong = 10000000000</em>
<p>Para que no ocurra añadir que es un Long con L</p>
<em>long numLong = 10000000000L</em>

<p>El compilador interpreta que los numeros con decimales son doubles.</p>

<p>para que le compilador entienda que lo que metes es float indicar la F al final del numero:</p>
<em>float numFloat = 10.5F</em>
<p>de no hacer esto habría que hacer un cast</p>
<em>float numFloat = (float) 10.5</em>



<p><b>NOTA:</b></p>
<div class="center-horizontal">
<pre><code class="language-java">
long numLong;
numLong = 1_000_000L; //BIEN
numLong = 1_000_____000L; //BIEN
numLong = _1_000_000L; //MAL ya que empieza por guión bajo
</code></pre>	
</div>


<h2>Clases envoltorio</h2>

<p>Cada dato primitivo tiene su representación en una clase envoltorio o wrapped class.</p>
<p>Estas clases contienen métodos estáticos que permiten convertir tipos de datos.</p>
<p>Los objetos de las clases envoltorio son inmutables.</p>

<div class="center-horizontal">
<pre><code class="language-java">
Integer num = Integer.MAX_VALUE;
Boolean valorMaximo = letra.equals('b');
Double valorMinimo = Double.MIN_VALUE;

//Conversion de datos
int n = Integer.parseInt("300");
</code></pre>	
</div>

<h4>Autoboxing/Unboxing</h4>

<p>Asignar el tipo primitivo a varible con clase envoltorio es <b>Autoboxing</b></p>
<p>Recuperar el tipo primitivo es <b>Unboxing</b></p>

<div class="center-horizontal">
<pre><code class="language-java">
Integer num = 111; //autoboxing
int num2 = num; //unboxing
</code></pre>	
</div>



<h2>String</h2>

TODO: cuando comparas dos string se compara los hascode: str1 == str2
TODO: no se esta comparando el valor

<p>Un objeto de la clase String es una cadena de caracteres inmutable, no se pueden modificar.</p>
<p>Los métodos que operan con String devuelven una copia de la cadena modificada</p>
<div class="center-horizontal">
<pre><code class="language-java">
// Se pueden crear:
String n1 = new String("mi cadena");// Deprecated
// o bien:
String n1 = "mi cadena";
</code></pre>	
</div>

<p>Métodos útiles</p>
<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Métodos para Strings</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Método</th>
            <th>Retorno</th>
            <th>Funcionalidad</th>
        </tr>
        <tr>
            <td>name.length()</td>
            <td>int</td>
            <td>Devuelve la longitud de la cadena.</td>
        </tr>
        <tr>
            <td>name.toLowerCase()</td>
            <td>String</td>
            <td>Devuelve la cadena de caracteres en minúsculas.</td>
        </tr>
        <tr>
            <td>name.toUpperCase()</td>
            <td>String</td>
            <td>Devuelve la cadena de caracteres en mayúsculas.</td>
        </tr>
        <tr>
            <td>name.substring([int a], [int b])</td>
            <td>String</td>
            <td>Devuelve un trozo de cadena comprendido entre las posiciones a y b-1</td>
        </tr>
        <tr>
            <td>name.split(" ")</td>
            <td>String[]</td>
            <td>Divide una cadena cada vez que encuentra un delimitador que coincida con la expresión regular pasada como parámetro.</td>
        </tr>
        <tr>
            <td>name.charAt([int pos])</td>
            <td>char</td>
            <td>Devuelve el caracter que ocupa la posición indicada.</td>
        </tr>
        <tr>
            <td>name.indexOf([String cad])</td>
            <td>int</td>
            <td>Devuelve la posición del parámetro</td>
        </tr>
        <tr>
            <td>name.replace([String c1],[String c2])</td>
            <td>String</td>
            <td>Devuelve la cadena resultante de reemplazar la subcadena c1 por c2.</td>
        </tr>
        <tr>
            <td>name.replaceAll([expresion regular],[String])</td>
            <td>String</td>
            <td>Acepta expresiones regulares.</td>
        </tr>
        <tr>
            <td>name.startsWith([String s])</td>
            <td>boolean</td>
            <td>Indica si la cadena empieza, respectivamente, por el texto recibido.</td>
        </tr>
        <tr>
            <td>name.endsWith([String s])</td>
            <td>boolean</td>
            <td>Indica si la cadena termina, respectivamente, por el texto recibido.</td>
        </tr>
        <tr>
            <td>name.trim()</td>
            <td>String</td>
            <td>Devuelve la cadena resultante de eliminar espacios al principio y al final de la misma</td>
        </tr>
        <tr>
            <td>name.concat([String s])</td>
            <td>String</td>
            <td>Mismo efecto que aplicar el operador +</td>
        </tr>
        <tr>
            <td>name.isEmpty()</td>
            <td>boolean</td>
            <td>Devuelve true si es una cadena vacía. Equivale a name.equals([String])</td>
        </tr>
        <tr>
            <td>name.equals([String])</td>
            <td>boolean</td>
            <td>Devuelve true si es una cadena vacía.</td>
        </tr>
        TODO:
        <tr>
            <td>name.contains([String que se desea buscar])</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>name.isBlank()</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>name.repeat([int numero de veces a repetir])</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>name.strip()</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>name.toCharArray()</td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>

<h2>String Builder</h2>

<p>Representa cadenas de caracteres mutables, se pueden modificar a través de los métodos de la clase.</p>
<p>Los métodos operan sobre el propio objeto.</p>
<p>Se crean:</p>
<div class="center-horizontal">
<pre><code class="language-java">
//Instanciación de StringBuilder:
StringBuilder sb = new StringBuilder("cadena mutable");
</code></pre>	
</div>
<p>
    No admite concatenación entre ellos, pero si con String (llamada a toString ()), devolviendo un nuevo String:
</p>
<div class="center-horizontal">
<pre><code class="language-java">
String s= "hola" + sb;
System.out.println(s);//muestra: hola cadena mutable
</code></pre>	
</div>

<!-- Métodos StringBuilder -->
<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Métodos para StringsBuilder</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Método</th>
            <th>Retorno</th>
            <th>Funcionalidad</th>
        </tr>
        <tr>
            <td>name.append([tipo dato])</td>
            <td>StringBuilder</td>
            <td>(tipo dato). Método sobrecargado para añadir cualquier tipo Java a la cadena. Modifica la cadena original y devuelve una referencia al propio objeto</td>
        </tr>
        <tr>
            <td>name.insert([int pos],[tipo dato])</td>
            <td>StringBuilder</td>
            <td>pos, tipo dato). Inserta un dato dentro de la cadena en la posición indicada</td>
        </tr>
        <tr>
            <td>name.replace([int a],[tipo b],[String s])</td>
            <td>StringBuilder</td>
            <td>Reemplaza los caracteres que se encuentran situados entre las posiciones a y b 1 por la cadena que se indica como tercer parámetro</td>
        </tr>
        <tr>
            <td>name.delete([int a],[int b])</td>
            <td>StringBuilder</td>
            <td>Elimina de la cadena los caracteres situados entre las posiciones a y b 1</td>
        </tr>
        <tr>
            <td>name.reverse()</td>
            <td>StringBuilder</td>
            <td>Invierte la cadena.</td>
        </tr>
        <tr>
            <td>name.compareTo([StringBuilder another])</td>
            <td>int</td>
            <td>Devuelve 1 si la cadena pasada como parámetro es menor (lexicográficamente) que la principal, 1 si es mayor y 0 si son iguales.</td>
        </tr>
    </tbody>
</table>
<!-- Métodos StringBuilder END -->

<h2>Inferencia de tipos</h2>

<p>Característica incorporada en Java 10, consistente en declarar variables locales sin indicar explícitamente el tipo.</p>

<p>Se emplea la palabra "var":</p>

<div class="center-horizontal">
<pre><code class="language-java">
var num=100; //entero
var datos=new ArrayList&lt;Integer&gt;(); //ArrayList de enteros
</code></pre>	
</div>

<p>El tipo es inferido por el compilador a partir del valor asignado a la variable</p>
<p>Simplifica la escritura de código, ni mejora ni empeora el rendimiento de la aplicación</p>

<p>Únicamente puede utilizarse con variables locales:</p>

<p>Es obligatorio asignar explícitamente un valor a la variable, valor que no puede ser null:</p>

<div class="center-horizontal">
<pre><code class="language-java">
class Test{
    var prueba=100; //error de compilación
    void print(){
    var res="success"; //correcto
    }
}
        
var data; //error de compilación
var n=null; //error de compilación
</code></pre>	
</div>


<p>No es posible utilizar inferencia de tipos en declaraciones múltiples:</p>

<p>Se puede utilizar inferencia de tipos en bucles de tipo for:</p>

<p>En arrays, no puede utilizarse con inicialización abreviada:</p>


<div class="center-horizontal">
<pre><code class="language-java">
var a,c=10; //incorrecto
var b=5,x=30; //incorrecto

for(var i=0;i&lt;10;i++){
}

for(var s:datos){
}

var s={5,9,10}; //incorrecto
var d=new int[]{5,1,3}; //correcto
</code></pre>	
</div>

<p><b>NOTA:</b> "var" es el único tipo de dato que se puede utilizar como nombre de una variable, sin que esta se considere palabra reservada.</p>

<div class="center-horizontal">
<pre><code class="language-java">
var b=DriverManager.getConnection(cadena,user,pass);
var ej=3/0;
var cad="";
var n=null;
var c, p=10;
var [] n=new int[4];
</code></pre>	
</div>

<p>
    Las instrucciones 1, 2 y 3 son correctas, mientras que 4, 5 y 6 son incorrectas. La instrucción f es incorrecta porque con var no se usan los corchetes en la declaración de arrays. La c no es correcta porque no se puede utilizar en declaraciones múltiples.
</p>

<h2>Cast o conversión de tipos</h2>
TODO:

<h2>Lista de palabras reservadas</h2>
TODO: