<h1 class="title">Listas</h1>

➢Una colección es una agrupación de objetos sin tamaño fijo
➢Se puede añadir y eliminar objetos de una colección
dinámicamente
➢Para gestionar colecciones disponemos de clases e interfaces
específicas en java.util
➢Tipos:
➢Listas
➢Tablas
➢Conjuntos

<h2>Listas</h2>
TODO: extends y super en operador diamante???? 
TODO: insertar imagen de jerarquias de la clase arraylist linkedList y vector

➢Cada elemento tiene una posición asociada a partir del orden
de llegada, siendo 0 la posición del primero
➢Las listas implementan la interfaz List, que a su vez
implementa Collection.
➢Son colecciones de tipo genérico (preparadas para admitir
cualquier objeto Java)
➢La principal clase de colección es ArrayList.

<h4>Creacion de listas</h4>
➢Como instancias de ArrayList:

➢A partir del método asList de Arrays:

➢Mediante método de factoría de List:

➢Mediante el método copyOf de List:
List<Integer> enteros=new ArrayList<>();

List<Integer> enteros=Arrays.asList(6,2,4,10,21);

List<Integer> enteros=List.of(40,29,11,28);

INMUTABLES, no admiten la
eliminación, modificación e
inserción de elementos, ni

valores null

<h4>Principales métodos para listas</h4>


<!---======================-->
<table class="table table-striped table-hover">
    <thead>
        <tr>
            <th>Métodos para List</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Método</th>
            <th>Retorno</th>
            <th>Funcionalidad</th>
        </tr>
        <tr>
            <td>name.append([tipo dato])</td>
            <td>StringBuilder</td>
            <td>(tipo dato). Método sobrecargado para añadir cualquier tipo Java a la cadena. Modifica la cadena original y devuelve una referencia al propio objeto</td>
        </tr>
    </tbody>
</table>
<!---======================-->

➢boolean add(T dato). Añade el dato a la colección y lo coloca
al final de la misma. T representa el tipo indicado al crear el
objeto de colección:

➢boolean add(int pos,T dato). Añade el elemento en la
posición indicada, desplazando hacia adelante los que se
encuentren en dicha posición

ArrayList<String> nombres=new ArrayList<>();
nombres.add(“Maria”); //elemento en posición 0
nombres.add(“Angel”); //elemento en posición 1

nombres.add(“Luis”, 1); //desplaza a Angel a la posición 2

➢T set(int pos, T dato). Sustituye el elemento existente en la
posición indicada por el nuevo dato suministrado como
parámetro. Devuelve el elemento sustituido

➢int size(). Devuelve el total de elementos de la colección
➢T get(int pos). Devuelve el elemento que ocupa la posición
indicada. Si la posición es menor que 0 o mayor o igual que size(),
se producirá una excepción

➢T remove (int pos). Elimina el elemento que ocupa la posición
indicada y lo devuelve. Si la posición es menor que 0 o mayor o
igual que size(), se producirá una excepción

➢boolean remove(Object ob). Elimina el elemento indicado en
caso de que exista. Devuelve true si dicho elemento estaba
presente en la colección. Si hay más de un elemento, elimina la
primera ocurrencia



<div class="center-horizontal">
<pre><code class="language-java">
List&lt;Integer&gt; nums=List.of(11,22,31,10);
nums.set(0,nums.get(1)); //EXCEPCION EN ESTA LINEA
System.out.println(nums.get(2)-nums.get(0));
</code></pre>	
</div>

<p>Se producirá una excepción en la segunda instrucción, ya que se trata de una lista inmutable y no se puede modificar su contenido</p>

<h4>Recorrido de una lista</h4>
➢Se puede recorrer con un bucle for estándar:

➢También mediante un for each:

➢Método forEach (se estudia en lambdas)


<div class="center-horizontal">
<pre><code class="language-java">
List&lt;Integer&gt; nums=new ArrayList(List.of(6,11,22,31,10,5,7)); //1
for(int k=0;k&lt;nums.size();k++) {
    if(nums.get(k)%2==0) {
    nums.remove(k);
    }
}
System.out.println(nums);
</code></pre>	
</div>

<p>La primera instrucción compila bien, es posible crear un ArrayList a partir de un Collection. El ArrayList es mutable, por lo que se puede modificar su contenido y la línea 2 es correcta.</p>


