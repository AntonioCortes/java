<h1 class="title">Métodos Streams</h1>

<!-- *****Stream Methods***** -->
<h2>Conteo y procesado</h2>

<p>long <b>count().</b> Devuelve el número de elementos de un Stream. <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream st = Stream.of(1,5,4,8,9,7,3,6);
//indica el total de elementos
System.out.println(st.count()); //8
</code></pre>
</div>

<p>void <b>forEach (Consumer&lt;? super T&gt; action)</b>. Realiza una acción para cada elemento del stream. <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream st = Stream.of(1,5,8,7,3,9,7);
//muestra todos los elementos
st.forEach(n-&gt;System.out.println(n));
System.out.println(st.count()); //ERROR!!!
//Tras llamar a un Stream se cierra y no puede volver a utilizarse.
</code></pre>
</div>
<!-- *********************** -->

<!-- *****Stream Methods***** -->
<h2>Extracción de datos</h2>

<p>Stream&lt;T&gt; <b>distinct()</b>. Devuelve un Stream eliminando los elementos duplicados, según aplicación de equals(). <em>Método intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; st = Stream.of(8,9,7,1,3,1,1,1);
//Cuenta el total de números no repetidos
System.out.println(st.distinct().count()); //5
</code></pre>
</div>

<p>Stream&lt;T&gt; <b>limit(long n)</b>. Devuelve un nuevo Stream con los "n" primeros elementos del mismo. <em>Método intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; st = Stream.of(2,5,8,6,4,8,4);
//Devuelve un Stream formado por 2,5 y 8
Stream&lt;Integer&gt; st2 = st.limit(3).
</code></pre>
</div>
    
<p>Stream&lt;T&gt; <b>skip(long n)</b>. Devuelve un nuevo Stream , saltándose los n primeros elementos. <em>Método intermedio</em></p>
<!-- *********************** -->

<!-- *****Stream Methods***** -->
<h2>Comprobaciones</h2>

<p>boolean <b>anyMatch(Predicate&lt;? super T&gt; predicate)</b>. Devuelve true si algún elemento del Stream cumple con la condición del predicado: <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream st = Stream.of(1,5,7,8,9,,5,4,2);
//indica si alguno es mayor de 5
System.out.println("alguno mayor 5?" + st.anyMatch(n-&gt;n&gt;5)); //true
</code></pre>
</div>

<p>boolean <b>allMatch(Predicate&lt;? super T&gt; predicate)</b>. Devuelve true si todos cumplen con la condición del predicado. <em>Método final</em></p>
<p>boolean <b>noneMatch(Predicate&lt;? super T&gt; predicate)</b>. Devuelve true si ninguno cumple con la condición del predicado. <em>Método final</em></p>
<!-- *********************** -->

<!-- *****Stream Methods***** -->
<h2>Filtrado</h2>

<p>Stream &lt;T&gt; <b>filter(Predicate &lt;? super T&gt; predicate)</b>. Aplica un filtro sobre el Stream , devolviendo un nuevo Stream con los elementos que cumplen el predicado: <em>Método intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; st = Stream.of(1,5,7,9,7,4,6,4,8,4,3,1);
    //cuenta el total de números mayores de 3
    //no duplicados
    System.out.println(st
    .distinct()
    .filter(s-&gt;s&gt;3)
    .count());
</code></pre>
</div>
<!-- *********************** -->

<!-- *****Stream Methods***** -->
<h2>Búsquedas</h2>

<p>Optional &lt;T&gt; <b>findFirst()</b>. Devuelve el primer elemento del Stream , o un Optional vacío si no hay nada. <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; st = Stream.of(11,5,8,3,9);
//devuelve el primer par
Optional&lt;Integer&gt; op = st
    .filter(s-&gt;s%2==0)
    .findFirst();
if(op.isPresent()){
    System.out.println("El primer par es "+op.get());
}
</code></pre>
</div>

<p>Optional&lt;T&gt; <b>findAny()</b>. Devuelve cualquiera de los elementos del Stream . Normalmente, el primero. <em>Método final</em></p>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Obtención de extremos</h2>

<p>Optional &lt;T&gt; <b>max(Comparator&lt;? super T&gt; comparator)</b>. Devuelve el mayor de los elementos , según el criterio de comparación del objeto Comparator: <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; nums = Stream.of(20,3,5,7,1);
//muestra el mayor de los números del Stream
Optional&lt;Integer&gt; op = nums.max((a,b )-&gt;a-b);
System.out.println("mayor: "+op.get());
</code></pre>
</div>

<p>Optional &lt;T&gt; <b>min(Comparator&lt;? super T&gt; comparator)</b>. Operación contraria a max. <em>Método final</em></p>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Transformación</h2>

<p>Stream &lt;R&gt; <b>map(Function&lt;? super T, ? extends R&gt; mapper)</b>. Transforma cada elemento del Stream en otro según el criterio definido por el objeto Function que se le pasa como parámetro: <em>Métodos intermedios</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;String&gt; st = Stream.of("Juan," "Maria", "Ana").
//genera un Stream con los nombres en mayúsculas
Stream&lt;String&gt; st2 = st.map(s-&gt;s.toUpperCase());
</code></pre>
</div>

<p>IntStream <b>mapToInt(ToIntFunction&lt;? super T&gt; mapper)</b>. Aplica una función a cada elemento del Stream que genera un int de cada elemento. El resultado se devuelve como IntStream: <em>Métodos intermedios</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;String&gt; st = Stream.of("Juan," "Maria", "Ana");
//muestra la suma de todos los caracteres de los nombres
System.out.println(st
    .mapToInt(s-&gt;s.length())
    .sum());
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Transformación y aplanamiento</h2>

<p>Stream&lt;R&gt; <b>flatMap(Function&lt;T, Stream&lt;R&gt; mapper)</b>. Devuelve un nuevo Stream , resultante de unir los Streams generados por la aplicación de una función sobre cada elemento. <em>Método intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
List&lt;List &lt;String&gt;&gt; datos = Arrays.asList(
    Arrays.asList("Gema","María","Carlos"),
    Arrays.asList("Laura","Ana","Luis")
);
System.out.println(datos.stream()
    .flatMap(l-&gt;l.stream().map(s-&gt;s.length()))
    .filter(n-&gt;n&gt;4)
    .count()
);
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Stream de tipos primitivos</h2>

<p>Las interfaces <b>IntStream</b>, <b>DoubleStream</b> y <b>LongStream</b>, cuyos objetos son obtenidos mediante los métodos <b>mapToInt</b>, <b>mapToDouble</b> y <b>mapToLong</b>, respectivamente, proporcionan los siguientes métodos de cálculo:</p>

<ul>
    <li>int <b>sum()</b>. Método final que devuelve la suma de todos los elementos del stream. En DoubleStream y LongStream el tipo de devolución es double y long, respectivamente.</li>
    <li>OptionalDouble <b>average()</b>. Método final que devuelve la media encapsulada en un OptionalDouble en los tres casos </li>
    <li>OptionalInt <b>max()</b> y <b>min()</b>. Devuelven el mayor y menor de los números, respectivamente. En DoubleStream y LongStream el tipo de devolución es OptionalDouble y OptionalLong, respectivamente.</li>
</ul>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Procesamiento intermedio</h2>

<p>Stream&lt;T&gt; <b>peek(Consumer&lt;? super T&gt; proceso)</b>. Aplica el consumer a cada elemento del Stream, devolviendo un nuevo stream idéntico para continuar con la manipulación de los elementos: <em>Métodos intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; nums = Stream.of(20,5,8,3,9);
//muestra los pares y el total de éstos
System.out.println("total:"+nums
    .filter(n-&gt;n%2==0)
    .peek(n System.out.println("par: "+n))
    .count()
);

//Output
/*
*par: 20
*par: 8
*total: 2
*/
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Ordenación</h2>

<p>Stream&lt;T&gt; <b>sorted()</b>. Devuelve un Stream con loselementos ordenados, según el orden natural de los mismos. <em>Método intermedio</em></p>
<p>Stream&lt;T&gt; <b>sorted(Comparator&lt;? super T&gt; comparator)</b>. Devuelve un Stream con los elementos ordenados, según el criterio de comparación especificado. <em>Método intermedio</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;String&gt; st = Stream.of("casa","pelota","lampara","disco")
//muestra los nombres ordenados por número de caracteres
st.sorted((a,b)-&gt; a.length()-b.length())
    .forEach(s System.out.println(s));

//**************

Stream&lt;Persona&gt; st = Stream.of(new Persona("marco",34), new Persona("ana",28));
//muestra los nombres de las personas, ordenadas por edad
st.sorted(Comparator.comparing(p-&gt;g.getEdad()))
.forEach(p-&gt;System.out.println(p.getNombre()));
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Reducción</h2>

<p>Optional&lt;T&gt; <b>reduce(BinaryOperator&lt;T&gt; accumulator)</b>. Realiza la reducción de los elementos del stream a un único valor, utilizando la función proporcionada como parámetro: <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; nums = Stream.of(20,5,8,3,9);
//Calcula la suma de todos los elementos del Stream
System.out.println(nums
    .reduce((a,b)-&gt;a+b)
    .get()
);
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Reducción a colección</h2>

<p>R <b>collect(Collector&lt;? super T, A, R&gt; collector)</b>. Devuelve un List, Map o Set con los datos del Stream, en función de la implementación de Collector proporcionada: <em>Método final</em></p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Integer&gt; nums = Stream.of(20,5,8,8,3,3,9);
//Genera una lista con los elementos del Stream sin duplicados
List&lt;Integer&gt; = nums.distinct().collect(Collectors.toList());
Stream&lt;Persona&gt; personas = Stream.of(new Persona("Jaime",5431),
    new Persona("Marta",5213),
    new Persona("Pilar",6792)
);
//genera una tabla con los datos de las personas, utilizando el dni como clave
//y el nombre como valor
Map&lt;Integer,String&gt; lista = personas
    .collect(Collectors.toMap(p-&gt;p.getDni(),p-&gt;p.getNombre()));
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Agrupación</h2>

<p>Utilizando el método <b>collect()</b> de Stream , se puede generar una agrupación de objetos utilizando el siguiente método de Collectors</p>
<p>Collector&lt;T, ?, Map &lt;K, List&lt;T&gt; <b>groupingBy( Function &lt;? super T, ? extends K&gt; classifier)</b>. Devuelve un Collector que implementa una agrupación de tipo groupBy . El método recibe como parámetro un objeto Function con el criterio de agrupación. Con este tipo de Collector , la llamada a <b>collect()</b> devolverá un Map de listas. Cada elemento del mapa tiene una clave, que es el dato por el que se hace la agrupación, y un valor con la lista de objetos de cada grupo.</p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Persona&gt; st = Stream.of(
    new Persona("Juan",30,"jj@gmail.com"),
    new Persona("Ana",40,"anaj@gmail.com"),
    new Persona("Bea",35,"bae@gmail.com"),
    new Persona("Pedro",40,"bae@gmail.com")
);
//agrupa las personas por edad
Map&lt;Integer, List&lt;Persona&gt;&gt; personas = st.collect(Collectors.groupingBy(p-&gt;p.getEdad()));
personas.forEach((k,v)-&gt;System.out.println(v));
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Partición</h2>

<p>Mediante el siguiente método de Collectors podemos proporcionar una implementación de collect() que genere una partición:</p>
<p>Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; <b>partitioningBy(Predicate&lt;? super T&gt; predicate)</b>. Devuelve un Collector para generar una agrupación Map de clave boolean y valor lista de objetos. El método recibe como parámetro un predicate para aplicar la condición a cada elemento, de modo que los que la cumplan serán agrupados en una lista con clave true, y los que no en otra lista con clave "false".</p>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Persona&gt; st Stream.of(new Persona("Juan",15,"jj@gmail.com"),
    new Persona("Ana",23,"anaj@gmail.com"),
    new Persona("Bea",16,"bae@gmail.com"),
    new Persona("Pedro",34,"bae@gmail.com")
);
//agrupa las personas menores de edad por un lado, y mayores por otro
Map&lt;Boolean,List &lt;Persona&gt;&gt; personas = st.collect(Collectors.partitionBy(p-&gt;p.getEdad()&gt;18));
</code></pre>
</div>
<!-- *********************** -->
<!-- *****Stream Methods***** -->
<h2>Otras implementaciones de Collector</h2>

<p>Collectors ofrece estos otros métodos de interés:</p>

<ul>
    <li>Collector&lt;T, ?, Double&gt; <b>averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</b>. Permite calcula la media a partir de los valores devueltos por la función. Existe también averagingInt y averagingLong.</li>
    <li>Collector&lt;T, ?, Integer&gt; <b>summingInt(ToIntFunction&lt;? super T&gt; mapper)</b>. Permite calcular la suma a partir de los valores devueltos por la función. Existe también summingLong y summingDouble.</li>
    <li>Collector&lt;CharSequence , ?, String&gt; <b>joining(CharSequence delimiter)</b>. Devuelve un Collector que concatena en un único String todos los String resultantes de la llamada a toString() sobre cada objeto del Stream.</li>
</ul>

<div class="center-horizontal">
<pre><code class="language-java">
Stream&lt;Persona&gt; st = Stream.of(
    new Persona("Juan",30,"jj@gmail.com")
    new Persona("Ana",40,"anaj@gmail.com"),
    new Persona("Bea",35,"bae@gmail.com")
);
//imprime los nombres de todas las personas, separados por una coma
System.out.println(st
        .map(p-&gt;p.getNombre())
        .collect(Collectors.joining(","))
);
</code></pre>
</div>
<!-- *********************** -->