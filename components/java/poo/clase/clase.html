<h1 class="title">Clase</h1>

TODO: POJO vs BEAN chatGPT?

<h2>Clase</h2>
TODO: this y super tiene que ser la primera linea, mismo comportamiento distinta referencia

<p><b>Definición:</b> Conjunto finito o infinito, tomado como un todo, de objetos que se distinguen por un determinado rasgo. Los objetos que constituyen la clase se denominan elementos de la misma. Tales elementos pueden ser no sólo individuos, sino también clases, por lo que se habla de diferentes tipos de clases. Generalmente, las clases se definen partiendo de las propiedades comunes a todos sus elementos.</p>
<p>Ejemplo:</p>

<div class="center-horizontal">
<pre><code class="language-java">
void class MyClase(){
    //...
}
</code></pre>	
</div>

<h2>Static</h2>
<ul>
    <li>Una clase estática no requiere de instanciar un objeto </li>
    <li>Si su atributo es estatico el valor de este es compartido por todos sus objetos ya que actua sobre la clase.</li>
</ul>

<h2>Bloque estático e inicializador de instancia</h2>

<div class="center-horizontal">
<pre><code class="language-java">
void class MyClase(){
    //ORDEN DE EJECUCIÓN...
    static{
        System.out.println("Bloque inicializador statico"); //1
    }
    {
        System.out.println("Bloque inicializador de instancia"); //2
    }
    public MyClase(){
        System.out.println("Constructor"); //3
    }
}
</code></pre>	
</div>


<h2>Constructor</h2>

<p>Toda clase tiene implícito un constructor sin argumentos que crea el compilador, a no ser que se defina explicitamente uno con argumentos.</p>
<p>Bloques de código que se ejecutan al crear un objeto de la clase.</p>
<p>Como los métodos, pueden recibir parámetros, aunque no tienen tipo de devolución y su nombre siempre es igual al de la clase.</p>
<p>En java existe la <b>sobrecarga de constructores</b>. Estos siguen las mismas reglas que los métodos.</p>

<div class="center-horizontal">
<pre><code class="language-java">
void class MyClase(){

    int a,b,c;

    public MyClase(int a){
        //...
    }
    public MyClase(int a, int b){
        //...
    }
    public MyClase(int a, int b, int c,){
        //...
    }
}
</code></pre>	
</div>


<h2>Nombre</h2>



<h2>Effectiviley final</h2>

<p>effectively final es un término que se utiliza en Java para describir una variable que se comporta como si fuera final, pero que técnicamente no está declarada como tal.

    En Java, una variable declarada con la palabra clave final no puede ser reasignada después de su inicialización, lo que significa que su valor no puede cambiar. Sin embargo, en algunos casos puede ser útil poder cambiar el valor de una variable dentro de un bloque de código o de una expresión lambda, por ejemplo.
    
    Es aquí donde entra en juego el concepto de effectively final. Una variable se considera effectively final si se le asigna un valor solo una vez, y este valor no se cambia después. Es decir, aunque la variable no se haya declarado explícitamente como final, se comporta como tal y no se puede cambiar su valor en la práctica.
    
    La ventaja de utilizar variables effectively final es que se pueden usar en expresiones lambda y en clases anónimas, que requieren que las variables locales a las que se accede dentro de ellas sean final o effectively final. De esta forma, se pueden escribir expresiones más concisas y legibles.</p>


<h2>Tipo de devolución</h2>
<h2>Parámetros</h2>
<h2>Getters Setters</h2>
<h2>toString</h2>

<h2>Clases record</h2>

<p><b>record</b> es una característica introducida en Java 16 que permite definir clases de datos simples y compactas en una sola línea de código. En esencia, un record es una clase que se define para representar un conjunto de datos inmutables que se utilizan para transportar datos dentro de la aplicación.</p>

<div class="center-horizontal">
<pre><code class="language-java">
public record NombreRecord(atributo1, atributo2, ..., atributoN) { 
    // cuerpo del record 
}
</code></pre>
</div>