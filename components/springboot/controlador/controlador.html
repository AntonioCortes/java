<h1 class="title">Controladores</h1>

<h2>Controlador</h2>

<p>Para definir una clase como controlador debe tener una serie de anotaciones que son las siguientes:</p>

<ul>
	<li><b>@RestController:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.RestController y sirve para registrar la clase como controlador, en la dirección indicada en la anotacion @RequestMapping.</li>
	<li><b>@RequesMapping:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.RequestMapping y sirve para definir la dirección para acceder al controlador.</li>
</ul>

<p>Una vez definidas las anotaciones anteriores la clase ya funcionará como un controlador, adicionalmente se le pueden añadir más anotaciones con distintas funcionalidades como las siguientes:</p>

<ul>
	<li><b>@CrossOrigin:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.CrossOrigin. <br>
		Por defecto springboot bloquea los intentos de acceso a los controladores a no ser que se permitan esos accesos específicamente, para permitir dichos accesos se utiliza la anotacion @CrossOrigin. 
		Si la anotación se pone sobre la definición de una clase se podrá acceder desde cualquier dirección a todos los métodos de la clase, si se coloca sobre un método se podrá acceder desde cualquier dirección a ese método. <br> 
		También se puede especificar que solo se pueda acceder a un método o a todos los métodos de la clase desde una dirección en concreto (por ejemplo desde la dirección desde donde esté servido el front-end, 
		de esta manera solo dicho front-end podrá acceder al controlador) especificándolo de la siguiente manera: @CrossOrigin(origin="http://dominio-permitido.com")
	</li>
</ul>

<h2>Anotaciones para documentación Swagger con la librería SpringFox</h2>

<ul>
	<li><b>@Api:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.Api y sirve para documentar lo que hace un controlador y que posteriormente se muestre en el Swagger ui si el proyecto está correctamente configurado para ello</li>

	<li><b>@ApiOperation:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.ApiOperation y sirve para documentar lo que hace cada endpoint (cada método del controlador) y que posteriormente se muestre en la Swagger ui si el proyecto está correctamente configurado para ello.</li>

	<li><b>@ApiResponses:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.ApiResponses y sirve para documentar las posibles respuestas que puede devolver un controlador o un método del controlador. Cada posible respuesta se definirá mediante la anotación @ApiResponse. <br>
		Dicha documentación podrá mostrarse posteriormente en Swagger ui.
	</li>

	<li><b>@ApiResponse:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.ApiResponse y sirve para especificar como va a ser una respuesta de las que se estén documentando con la anotación @ApiResponses</li>

	<li><b>@ApiParam:</b> Esta anotación pertenece a Springfox Framework, se encuentra en el paquete io.swagger.annotations.ApiParam y sirve para documentar cada uno de los parámetros de cada endpoint (cada método del controlador) y que posteriormente se muestre en la Swagger ui si el proyecto está correctamente configurado para ello.</li>
</ul>


<div class="center-horizontal">
<pre><code class="language-java">
@RestController
@RequestMapping("/petshop/pets")
@CrossOrigin
@Api(tags = "Pets")
@ApiResponses({ @ApiResponse(code = 200, message = "OK", response = PetDTO.class),
		@ApiResponse(code = 201, message = "Created"),
		@ApiResponse(code = 204, message = "No content")
		@ApiResponse(code = 400, message = "Bad Request"),
		@ApiResponse(code = 404, message = "Not found"), 
		@ApiResponse(code = 500, message = "Internal server error") })
public class PetController 
{
	//...Controller global attributes
	//...Controller methods
}	
</code></pre>	
</div>

<h2>Atributos globales del controlador</h2>

<div class="center-horizontal">
<pre><code class="language-java">
public class PetController
{
	private static final Logger LOGGER = LoggerFactory.getLogger(PetController.class);

	@Autowired
	PetService petService;

	@Autowired
	@Qualifier("modelMapper")
	private ModelMapper mapper;

	@Autowired
	@Qualifier("patchModelMapper")
	private ModelMapper patchMapper;

	//...Controller methods
}
</code></pre>
</div>

<h2>Métodos del controlador</h2>

<h3>GET</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "View a pet data", notes = "View a pet data")
@ApiResponses({ @ApiResponse(code = 200, message = "OK", response = PetDTO.class), 
		@ApiResponse(code = 404, message = "Not found") })
@GetMapping("/{id}")
public ResponseEntity< PetDTO> get(@PathVariable(value = "id") @ApiParam(value = "pet Id", example = "1", required = true) final Integer pId) 
{
	Optional< Pet> pet = petService.findById(pId);
	if(pet.isEmpty()) 
	{
		LOGGER.error("Pet {} not found", pId);
		return new ResponseEntity<>(HttpStatus.NOT_FOUND);
	}
	PetDTO petDTO = mapper.map(pet.get(), PetDTO.class);
	LOGGER.debug("Getting pet {}", petDTO);

	return new ResponseEntity<>(petDTO, HttpStatus.OK);
}
</code></pre>	
</div>

<h3>PATCH</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "Update a pet", notes = "Update a pet")
@ApiResponses({ @ApiResponse(code = 204, message = "No content"),
		@ApiResponse(code = 404, message = "Not found") })
@PatchMapping("/{id}")
public ResponseEntity< HttpStatus> patch(
		@PathVariable(value = "id") @ApiParam(value = "Pet id", example = "1", required = true) final Integer pId,
		@Valid @RequestBody final PetPatchDTO pPetPatchDTO) 
{

	Optional< Pet> pet = petService.findById(pId);
	if (pet.isEmpty()) 
	{
		LOGGER.error("Pet {} not found", pId);
		return new ResponseEntity<>(HttpStatus.NOT_FOUND);
	}

	patchMapper.map(pPetPatchDTO, pet.get());

	petService.save(pet.get());

	URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().build().toUri();

	HttpHeaders headers = new HttpHeaders();
	headers.setLocation(uri);

	return new ResponseEntity<>(headers, HttpStatus.NO_CONTENT);
}	
</code></pre>	
</div>

<h3>POST</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "Add a new pet", notes = "Add a new pet")
@ApiResponses({ @ApiResponse(code = 201, message = "Created") })
@PostMapping
public ResponseEntity< Object> post(@RequestBody @Valid final PetDTO pPetDTO) 
{
	Optional< Pet> petOp = petService.findById(pPetDTO.getId());
	if(petOp.isPresent())
	{
		LOGGER.error("Pet {} already exists", pPetDTO.getId());
		throw new UniqueConstraintException(ConstantMessages.ERROR_ALREADY_EXISTS);
	}
	
	Pet pet = mapper.map(pPetDTO, Pet.class);
	pet = petService.save(pet);
	LOGGER.debug("Pet whith id {} saved correctly", pet.getId());
		
	URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().pathSegment(String.format("%s", pet.getId())).build().toUri();
	HttpHeaders headers = new HttpHeaders();
	headers.setLocation(uri);

	return new ResponseEntity<>(headers, HttpStatus.CREATED);
}
</code></pre>	
</div>

<h3>DELETE</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "Delete a pet", notes = "Delete a pet")
@ApiResponses({ @ApiResponse(code = 204, message = "No content"), 
		@ApiResponse(code = 404, message = "Not found") })
@DeleteMapping("/{id}")
public ResponseEntity< HttpStatus> delete(@PathVariable(value = "id") @ApiParam(value = "Pet id", example = "1", required = true) final Integer pId)
{		
	Optional< Pet> pet = petService.findById(pId);
	
	if(pet.isPresent())
	{		
		petService.delete(pet.get());
		LOGGER.debug("Pet with id {} deleted correctly", pId);

		return new ResponseEntity<>(HttpStatus.NO_CONTENT);	
	}
	else
	{
		LOGGER.error("Pet with id {} don't exists", pId);

		return new ResponseEntity<>(HttpStatus.NOT_FOUND);	
	}
}
</code></pre>
</div>