<h1 class="title">Controladores</h1>

<h2>Controlador</h2>

<p>Para definir una clase como controlador debe tener una serie de anotaciones que son las siguientes:</p>

<ul>
	<li><b>@RestController:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.RestController y sirve para registrar la clase como controlador, en la dirección indicada en la anotacion @RequestMapping.</li>
	<li><b>@RequesMapping:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.RequestMapping y sirve para definir la dirección para acceder al controlador.</li>
</ul>

<p>Una vez definidas las anotaciones anteriores la clase ya funcionará como un controlador, adicionalmente se le pueden añadir más anotaciones con distintas funcionalidades como las siguientes:</p>

<ul>
	<li><b>@CrossOrigin:</b> Esta anotación es propia de Spring Framework, se encuentra en el paquete org.springframework.web.bind.annotation.CrossOrigin. <br>
		Por defecto springboot bloquea los intentos de acceso a los controladores a no ser que se permitan esos accesos específicamente, para permitir dichos accesos se utiliza la anotacion @CrossOrigin. 
		Si la anotación se pone sobre la definición de una clase se podrá acceder desde cualquier dirección a todos los métodos de la clase, si se coloca sobre un método se podrá acceder desde cualquier dirección a ese método. <br> 
		También se puede especificar que solo se pueda acceder a un método o a todos los métodos de la clase desde una dirección en concreto (por ejemplo desde la dirección desde donde esté servido el front-end, 
		de esta manera solo dicho front-end podrá acceder al controlador) especificándolo de la siguiente manera: @CrossOrigin(origin="http://dominio-permitido.com")
	</li>

	<li><b>@Api:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.Api y sirve para documentar lo que hace un controlador y que posteriormente se muestre en el Swagger ui si el proyecto está correctamente configurado para ello</li>

	<li><b>@ApiResponses:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.ApiResponses y sirve para documentar las posibles respuestas que puede devolver un controlador o un método del controlador. Cada posible respuesta se definirá mediante la anotación @ApiResponse. <br>
		Dicha documentación podrá mostrarse posteriormente en Swagger ui.
	</li>

	<li><b>@ApiResponse:</b> Esta anotación pertenece a SpringFox Framework, se encuentra en el paquete io.swagger.annotations.ApiResponse y sirve para especificar como va a ser una respuesta de las que se estén documentando con la anotación @ApiResponses</li>
</ul>


<div class="center-horizontal">
<pre><code class="language-java">
@RestController
@RequestMapping("/stores/attribute")
@CrossOrigin
@Api(tags = "Pet Shop")
@ApiResponses({ @ApiResponse(code = 404, message = "Not found"), 
		@ApiResponse(code = 400, message = "Bad Request"),
		@ApiResponse(code = 500, message = "Internal server error") })
public class PetShopController 
{
	//...Controller global attributes
	//...Controller methods
}	
</code></pre>	
</div>

<h2>Atributos globales del controlador</h2>

<div class="center-horizontal">
<pre><code class="language-java">
public class PetShopController
{
	private static final Logger LOGGER = LoggerFactory.getLogger(PetShopController.class);

	@Autowired
	PetShopService petShopService;

	@Autowired
	@Qualifier("modelMapper")
	private ModelMapper mapper;

	@Autowired
	@Qualifier("patchModelMapper")
	private ModelMapper patchMapper;

	//...Controller methods
}
</code></pre>
</div>

<h2>Métodos del controlador</h2>

<h3>GET</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiResponses({ @ApiResponse(code = 200, message = "OK", response = PetShopDTO.class) })
@GetMapping("/{id}")
public ResponseEntity<PetShopDTO> get(@PathVariable(value = "id") @ApiParam(value = "pet shop attribute Id", example = "1", required = true) final Integer id) 
{
	Optional< PetShop> petShop = petShopService.findById(id);
	if (petShop.isEmpty()) 
	{
		return new ResponseEntity<>(HttpStatus.NOT_FOUND);
	}
	PetShopDTO petShopDTO = mapper.map(petShop.get(), PetShopDTO.class);
	LOGGER.debug("Getting pet shop Attributes {}", PetShopDTO);

	return new ResponseEntity<>(PetShopDTO, HttpStatus.OK);
}
</code></pre>	
</div>

<h3>PATCH</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiResponses({ @ApiResponse(code = 204, message = "No content") })
@PatchMapping("/{id}")
public ResponseEntity< HttpStatus> patch(
		@PathVariable(value = "id") @ApiParam(value = "pet shop Id", example = "1", required = true) final Integer id,
		@Valid @RequestBody PetShopPatchDTO petShopDTO) 
{

	Optional< PetShop> petShop = petShopService.findById(id);
	if (petShop.isEmpty()) 
	{
		return new ResponseEntity<>(HttpStatus.NOT_FOUND);
	}

	patchMapper.map(petShopDTO, petShop.get());

	petShopService.save(petShop.get());

	URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().build().toUri();

	HttpHeaders headers = new HttpHeaders();
	headers.setLocation(uri);

	return new ResponseEntity<>(headers, HttpStatus.NO_CONTENT);
}	
</code></pre>	
</div>

<h3>POST</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "post pet shop", notes = "Post pet shop")
@PostMapping
@ApiResponses({ @ApiResponse(code = 201, message = "No content")})
public ResponseEntity< Object> post(@RequestBody @Valid final PetShopDTO pPetShopDTO) {

	Optional< PetShop> petShopOp = petShopService.findById(pPetShopDTO.getId());
	if(petShopOp.isPresent())
	{
		LOGGER.error(ConstantMessages.POST, ConstantMessages.PET_SHOP, pPetShopDTO.getId(), ConstantMessages.ERROR_ALREADY_EXISTS);
		throw new UniqueConstraintException(ConstantMessages.ERROR_ALREADY_EXISTS);
	}
	
	PetShop petShop = mapper.map(pPetShopDTO, PetShop.class);
	petShop = petShopService.save(petShop);
	LOGGER.debug(ConstantMessages.POST, ConstantMessages.PET_SHOP, petShop.getId(), ConstantMessages.OK);
		
	URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().pathSegment(String.format("%s", petShop.getId())).build().toUri();
	HttpHeaders headers = new HttpHeaders();
	headers.setLocation(uri);

	return new ResponseEntity<>(headers, HttpStatus.CREATED);
}
</code></pre>	
</div>

<h3>DELETE</h3>

<div class="center-horizontal">
<pre><code class="language-java">
@ApiOperation(value = "Delete pet shop", notes = "Delete pet shop")
@ApiResponses({ @ApiResponse(code = 204, message = "No content"), 
		@ApiResponse(code = 404, message = "Not found") })
@DeleteMapping("/{id}")
public ResponseEntity< HttpStatus> delete(@PathVariable(value = "id") @ApiParam(value = "pet shop Id", example = "1", required = true) final Integer id)
{		
	Optional< PetShop> petShop = petShopService.findById(id);
	
	if(petShop.isPresent())
	{
		LOGGER.debug(ConstantMessages.DELETE, ConstantMessages.PET_SHOP, id, ConstantMessages.OK);
		petShopService.delete(petShop.get());

		return new ResponseEntity<>(HttpStatus.NO_CONTENT);	
	}
	else
	{
		LOGGER.error(ConstantMessages.DELETE, ConstantMessages.PET_SHOP, id, ConstantMessages.ERROR_NOT_EXISTS);

		return new ResponseEntity<>(HttpStatus.NOT_FOUND);	
	}
}
</code></pre>
</div>