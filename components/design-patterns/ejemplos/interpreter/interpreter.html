<style>
    .title, .subtitle, strong {
        color: black !important;
    }
</style>
<h1 class="title">Patrón Interpreter</h1>

<p>El patrón <strong>Interpreter</strong> es un patrón de comportamiento que dado un lenguaje, define una representación de su gramática junto con un intérprete que usa la representación para interpretar sentencias del lenguaje.</p>

<h2 class="subtitle">Propósito</h2>
<p>Evaluar sentencias en un lenguaje simple definido por una gramática.</p>

<h2 class="subtitle">Caso de Uso Real: Intérprete de Expresiones Matemáticas o SQL</h2>
<p><strong>Contexto:</strong> Estás construyendo una calculadora que debe aceptar fórmulas complejas como Cadenas de Texto: <code class="language-java">"5 + (10 - 2)"</code> y evaluarlas.</p>

<p><strong>El Problema:</strong> Parsear y evaluar esto con un montón de <code class="language-java">if/else</code> o bucles anidados es extremadamente complejo y frágil ante cambios en la gramática.</p>

<p><strong>La Solución (Interpreter):</strong> Defines una gramática para el lenguaje. Cada regla de la gramática (Número, Suma, Resta) se convierte en una Clase.
<br>La sentencia se parsea en un árbol de objetos (Árbol de Sintaxis Abstracta). Para evaluar la expresión, simplemente llamas a <code class="language-java">interpret()</code> en la raíz del árbol, y la llamada se propaga recursivamente bajando por los nodos.</p>

<h2 class="subtitle">Análisis de la Implementación</h2>

<ul>
    <li>
        <strong>Representación de Gramáticas:</strong> 
        <p>El patrón mapea reglas gramaticales a clases. <code class="language-java">TerminalExpression</code> son los nodos hoja (números, variables), y <code class="language-java">OrExpression</code> (o Sum, Minus) son nodos compuestos que combinan otras expresiones.</p>
    </li>
    <li>
        <strong>Extensibilidad:</strong> 
        <p>Es fácil añadir nuevos operadores (ej. Multiplicación) simplemente creando una nueva clase <code class="language-java">Expression</code>, sin cambiar el código de las expresiones existentes. Sin embargo, si la gramática es muy compleja, el árbol de clases se vuelve inmanejable (en ese caso es mejor usar parsers generados como ANTLR).</p>
    </li>
</ul>

<h2 class="subtitle">Implementación</h2>

<div class="center-horizontal">
<pre><code class="language-java">
interface Expression {
    boolean interpret(String context);
}

class TerminalExpression implements Expression {
    private String data;
    public TerminalExpression(String data) { this.data = data; }
    public boolean interpret(String context) {
        return context.contains(data);
    }
}

class OrExpression implements Expression {
    private Expression expr1, expr2;
    public OrExpression(Expression expr1, Expression expr2) { ... }
    public boolean interpret(String context) {
        return expr1.interpret(context) || expr2.interpret(context);
    }
}
</code></pre>
</div>
<span class="center-horizontal caption">Ejemplo de Interpreter</span>
