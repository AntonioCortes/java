<style>
    .title, .subtitle, strong {
        color: black !important;
    }
</style>
<h1 class="title">Patrón State</h1>

<p>El patrón <strong>State</strong> es un patrón de comportamiento que permite que un objeto altere su comportamiento cuando su estado interno cambia. Parece como si el objeto cambiara su clase.</p>

<h2 class="subtitle">Propósito</h2>
<p>Permitir a un objeto cambiar su comportamiento cuando cambia su estado interno.</p>

<h2 class="subtitle">Caso de Uso Real: Ciclo de Vida de Pedidos o Reproductor Multimedia</h2>
<p><strong>Contexto:</strong> Un pedido en Amazon pasa por estados: "Nuevo" -> "Pagado" -> "Enviado" -> "Entregado". O un Reproductor de Vídeo (Play, Pause, Stop).</p>

<p><strong>El Problema:</strong> Si gestionas esto con variables booleanas (<code class="language-java">isPaid</code>, <code class="language-java">isShipped</code>) y sentencias <code class="language-java">if-else</code> o <code class="language-java">switch</code> gigantes en cada método (<code class="language-java">cancelarPedido()</code>), el código se vuelve monstruoso y muy propenso a bugs. Si el pedido está "Enviado", no puedes cancelarlo, pero si está "Pagado" sí.</p>

<p><strong>La Solución (State):</strong> Cada estado se convierte en una clase propia (<code class="language-java">EstadoNuevo</code>, <code class="language-java">EstadoEnviado</code>).
<br>El objeto Contexto (el Pedido) delega el comportamiento al objeto de estado actual. Si llamas a <code class="language-java">cancelar()</code>, el Pedido le dice a su estado actual "Cancélate". Si es <code class="language-java">EstadoEnviado</code>, dirá "No puedo"; si es <code class="language-java">EstadoNuevo</code>, dirá "Ok, hecho".</p>

<h2 class="subtitle">Análisis de la Implementación</h2>

<ul>
    <li>
        <strong>Eliminación de Condicionales:</strong> 
        <p>Reemplazamos máquinas de estado complejas basadas en <code class="language-java">switch</code> por polimorfismo. Añadir un nuevo estado implica simplemente añadir una nueva clase, no tocar la lógica existente de los otros estados.</p>
    </li>
    <li>
        <strong>Cambio de Comportamiento en Runtime:</strong> 
        <p>Parece que el objeto cambia de clase en tiempo de ejecución. Al cambiar el atributo <code class="language-java">state</code>, el objeto responde de forma totalmente distinta a los mismos métodos.</p>
    </li>
</ul>

<h2 class="subtitle">Implementación</h2>

<div class="center-horizontal">
<pre><code class="language-java">
interface State {
    void doAction(Context context);
}

class StartState implements State {
    public void doAction(Context context) {
        System.out.println("Player is in start state");
        context.setState(this);
    }
}

class StopState implements State {
    public void doAction(Context context) {
        System.out.println("Player is in stop state");
        context.setState(this);
    }
}

class Context {
    private State state;
    public void setState(State state) { this.state = state; }
    public State getState() { return state; }
}
</code></pre>
</div>
<span class="center-horizontal caption">Ejemplo de State</span>
