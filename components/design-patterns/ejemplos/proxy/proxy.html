<style>
    .title, .subtitle, strong {
        color: black !important;
    }
</style>
<h1 class="title">Patrón Proxy</h1>

<p>El patrón <strong>Proxy</strong> es un patrón estructural que proporciona un sustituto o marcador de posición para otro objeto. Un proxy controla el acceso al objeto original, permitiendo hacer algo antes o después de que la solicitud llegue al objeto original.</p>

<h2 class="subtitle">Propósito</h2>
<p>Controlar el acceso a un objeto. Puede ser para carga perezosa (Virtual Proxy), control de acceso (Protection Proxy), ejecución remota (Remote Proxy) o logging.</p>

<h2 class="subtitle">Caso de Uso Real: Carga Diferida (Lazy Loading) de Imágenes</h2>
<p><strong>Contexto:</strong> Tienes una lista de productos con imágenes de alta resolución (10MB cada una). El usuario hace scroll rápido por la lista.</p>

<p><strong>El Problema:</strong> Si cargas todas las imágenes reales al arrancar la aplicación o al crear el objeto del producto, la aplicación tardará minutos en iniciar y consumirá toda la memoria, incluso para imágenes que el usuario quizá nunca llegue a ver (porque no hizo scroll hasta abajo).</p>

<p><strong>La Solución (Virtual Proxy):</strong> En lugar de la imagen real, pones un Proxy (un objeto ligero que ocupa poco).
<br>Cuando la interfaz gráfica llama a <code class="language-java">display()</code> en el Proxy porque el usuario ha hecho scroll y la imagen debe verse, EN ESE MOMENTO el Proxy carga la imagen real del disco y delega la llamada. Mientras tanto, puede mostrar un placeholder.</p>

<h2 class="subtitle">Análisis de la Implementación</h2>

<ul>
    <li>
        <strong>Misma Interfaz:</strong> 
        <p>El Proxy debe implementar <strong>la misma interfaz</strong> que el objeto real (<code class="language-java">Image</code>). Esto permite que el cliente trate al proxy y al objeto real de forma indistinta (Polimorfismo). El cliente no sabe (ni le importa) si la imagen está cargada o no.</p>
    </li>
    <li>
        <strong>Control de Ciclo de Vida:</strong> 
        <p>El Proxy es responsable de crear y destruir el objeto real (<code class="language-java">RealImage</code>). Esto le da el control para implementar optimizaciones como Lazy Loading o Caché.</p>
    </li>
</ul>

<h2 class="subtitle">Implementación</h2>

<div class="center-horizontal">
<pre><code class="language-java">
interface Image {
    void display();
}

class RealImage implements Image {
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(fileName);
    }

    private void loadFromDisk(String fileName) {
        System.out.println("Cargando imagen pesada: " + fileName);
    }

    @Override
    public void display() {
        System.out.println("Mostrando imagen: " + fileName);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String fileName;

    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}
</code></pre>
</div>
<span class="center-horizontal caption">Estructura Proxy (Virtual Proxy)</span>

<br>

<h2 class="subtitle">Ejemplo de Uso</h2>

<div class="center-horizontal">
<pre><code class="language-java">
public class Main {
    public static void main(String[] args) {
        Image image = new ProxyImage("foto_alta_resolucion.jpg");

        // La imagen no se carga todavía
        System.out.println("Proxy creado. Imagen no cargada.");

        // La imagen se carga del disco ahora
        image.display();

        // La imagen ya está cargada, no se recarga
        image.display();
    }
}
</code></pre>
</div>

<div class="center-horizontal">
<pre><code class="language-java">
Output:
Proxy creado. Imagen no cargada.
Cargando imagen pesada: foto_alta_resolucion.jpg
Mostrando imagen: foto_alta_resolucion.jpg
Mostrando imagen: foto_alta_resolucion.jpg
</code></pre>
</div>
