<h1 class="title">Patrón Strategy</h1>

<p>El patrón <strong>Strategy</strong> es un patrón de comportamiento que permite definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. Permite que el algoritmo varíe independientemente de los clientes que lo usan.</p>

<h2 class="subtitle">Propósito</h2>
<p>Permitir seleccionar un algoritmo en tiempo de ejecución. Evita grandes sentencias <code>switch</code> o <code>if-else</code>.</p>

<h2 class="subtitle">Caso de Uso Real: Procesamiento de Pagos en E-commerce</h2>
<p><strong>Contexto:</strong> Imagina una tienda online que acepta múltiples formas de pago: Tarjeta de Crédito, PayPal, Bitcoin, etc. Todos estos métodos tienen el mismo objetivo (pagar) pero la lógica interna para conectarse con el banco o la API es completamente diferente.</p>

<p><strong>El Problema:</strong> Sin el patrón Strategy, la clase encargada del pago (<code>Checkout</code>) tendría un método monstruoso lleno de sentencias <code>if (type == "PAYPAL") { ... } else if (type == "CARD") { ... }</code>. 
<br>Esto tiene graves consecuencias:
<ul>
    <li>Viola el <strong>Principio Open/Closed</strong>: Cada vez que quieras añadir un nuevo método de pago (ej. Apple Pay), tienes que modificar y recompilar la clase <code>Checkout</code>, arriesgándote a romper el funcionamiento de los pagos existentes.</li>
    <li>La clase <code>Checkout</code> se vuelve enorme y difícil de mantener.</li>
</ul></p>

<p><strong>La Solución (Strategy):</strong> El patrón sugiere sacar toda esa lógica de los <code>if-else</code> y encapsular cada algoritmo de pago en su propia clase independiente.
<br>
El <code>Checkout</code> ya no conoce los detalles, solo sabe que tiene un objeto que sabe "pagar" (implementa <code>PaymentStrategy</code>). Para añadir Apple Pay, solo creas una nueva clase, sin tocar ni una línea del código de <code>Checkout</code>.</p>

<h2 class="subtitle">Implementación</h2>

<div class="center-horizontal">
<pre><code class="language-java">
// Estrategia
interface PaymentStrategy {
    void pay(int amount);
}

// Estrategias Concretas
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Pagado " + amount + " usando Tarjeta de Crédito: " + cardNumber);
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Pagado " + amount + " usando PayPal: " + email);
    }
}

// Contexto
class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout(int amount) {
        if (paymentStrategy == null) {
            System.out.println("Seleccione un método de pago.");
        } else {
            paymentStrategy.pay(amount);
        }
    }
}
</code></pre>
</div>
<span class="center-horizontal caption">Estructura Strategy</span>

<br>

<h2 class="subtitle">Análisis de la Implementación</h2>

<ul>
    <li>
        <strong>Interfaz <code>PaymentStrategy</code>:</strong> 
        <p>Se utiliza una <strong>interfaz</strong> en lugar de una clase concreta para desacoplar el contexto (<code>ShoppingCart</code>) de las implementaciones específicas de pago. Esto define un contrato que todas las estrategias deben cumplir, permitiendo el <strong>Polimorfismo</strong>.</p>
    </li>
    <li>
        <strong>Composición sobre Herencia:</strong> 
        <p><code>ShoppingCart</code> tiene una referencia (composición) a <code>PaymentStrategy</code> en lugar de heredar de una clase de pago. Esto permite cambiar el comportamiento en tiempo de ejecución (<code>setPaymentStrategy</code>), algo que la herencia no permite dinámicamente.</p>
    </li>
</ul>

<h2 class="subtitle">Ejemplo de Uso</h2>

<div class="center-horizontal">
<pre><code class="language-java">
public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();

        // Pagar con PayPal
        cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
        cart.checkout(100);

        // Cambiar estrategia a Tarjeta
        cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456"));
        cart.checkout(200);
    }
}
</code></pre>
</div>

<div class="center-horizontal">
<pre><code class="language-plaintext">
Output:
Pagado 100 usando PayPal: user@example.com
Pagado 200 usando Tarjeta de Crédito: 1234-5678-9012-3456
</code></pre>
</div>
